# Ownership and Borrowing

# 소유권(Ownership)이란?
- Rust 프로그램이 메모리를 어떻게 관리할 지 결정하는 규칙들
- Rust 언어만의 고유한 부분

## 메모리 할당과 해제
지하철을 탈 때, 지하철의 자리는 한정된 자원. 
어떤 사람이 자리에 짐을 두고 내린 경우에는 짐의 주인이 없어졌음에도 다른 사람은 그 자리를 사용할 수 없게 됨. (불필요한 메모리의 차지 발생)

프로그램의 메모리 할당과 해제 역시 이와 비슷.
사용하지 않는 공간은 메모리를 비워줘야 효율적으로 다른 값을 담을 수 있음


## 메모리 관리 방식
1. GC(가비지 콜렉터) : 현대의 대부분의 언어 - Java, Go, Python, JS
	- 실행 시간(런타임) 중 때때로 더이상 쓰지 않는 메모리 정리
	- 개발하기 매우 편리 - 개발자는 따로 신경쓰지 않아도 됨
	- 운영 시 성능상 문제가 될 수도 있음 (대부분의 경우는 OK)
2. 수동으로 프로그래머가 메모리 관리 - C, C++
	- 개발자가 메모리 할당과 해제 작업을 코드로 지시
	- 최적의 속도. 실행 시 메모리 관리 부담 최소
	- 개발이 힘듦. 실수와 버그 발생의 원인...
3. 컴파일 시점에 메모리 관리 규칙을 검사 - Rust
	- 소유권 규칙을 정하여 해당 규칙에 따라 컴파일 시점에 메모리 할당과 해제를 컴파일러가 관리
	- 규칙에 어긋나면 컴파일 되지 않음 (오류발생)
	- 규칙을 잘 지키면 컴파일러가 처리해줌
	- 런타임에서의 메모리 손해가 없으면서도, 실수의 여지가 없음 (위 두가지 방식의 단점 해결)

## Rust의 메모리 할당/해제 방식
1. 변수의 범위 scope가 끝나면 메모리 해제 가능
	- 블록 내에서만 변수가 유효, 블록 외부에서는 무효
```rust
fn main() {
	{
		let str = "hello";
		println!("{str}");
	} // 여기서 해제 가능

	println!("{str}"); // ❌ 메모리 해제
}
```

2. 스택과 힙 메모리
	- 보통 언어에서는 구분해서 생각할 필요가 없지만 알면 좋은 개념
	- Rust에서는 잘 알아두는 것이 필수적!
	- 소유권 규칙을 잘 이해한 뒤에는 크게 신경쓰지 않아도 

**stack**
접시를 쌓듯 프로그램 진행되는 동안 공간을 계속해서 쌓아가는 방식
함수가 호출되면 새로운 stack이 쌓이고, 함수에서 반환값이 나와 빠져나갈 때는 쌓았던 공간을 다시 뺌

**heap**
넓은 공간을 할당해둔 뒤, 특정 위치에 접근해서 값을 사용하고 사용 후에는 해당 공간을 비우는 형태.
자유로운 위치에 접근 가능. 공간을 더 크게 할당할 수 있고,
공간이 부족하면 옆의 더 큰 공간으로 옮길 수 있고,
다 쓰고 나면 그 공간을 비우고 새로운 값을 저장할 수 있게 함

**문자열 리터럴과 String**
- 기본 데이터 타입은 Stack에서 쉽게 관리 가능
- 문자열 리터럴은 프로그램에 "고정"으로 확보 (heap ❌)
- 문자열 리터럴은 불변! immutable
- 그렇다면 사용자가 입력하는 문자열은 어떻게? - 미리 크기를 알 수 없는 값.
	-> 문자열 String 타입으로 관리

**문자열 String타입**
- 변경가능한 값 (mutable) : 길이가 늘어날 수 있음
- 따라서 컴파일 시점에 미리 크기를 알 수 없음
- 따라서 이 값은 heap에 메모리를 차지해야 함!
```rust
fn main() {
	let s = "hello"; // s : &str (문자열 리터럴) != String 타입
	// string 타입으로 만들기
	let ss: String = String::from("hello") 
	// String이라는 네임스페이스 내의 from 함수 사용
	// 문자열 리터럴 값이었던 "hello"가 String 값으로 heap에 위치한 뒤 ss라는 이름이 붙음
}
```

**문자열 String 값 바꾸기**
문자열 String 타입은 mutable로 값을 바꿀 수 있음
```rust
fn main() {
	let mut s: String = String::from("Hello");
	s.push_str(", World!");
	println!("{s}");
}
```

**문자열 String 타입의 메모리 할당**
- 실행 시점에 메모리 할당을 요청
- 메모리 할당한 문자열을 사용한 후에는? : 빈 공간으로 반납(사용가능한 메모리로 반환) 해야한다
	-> 여기서 필요한 것이 소유권규칙!


# 소유권 규칙
- Rust에서 모든 값은 소유자(Owner)가 있음
- 한 시점에 딱 하나의 소유자만 있을 수 있다
- 소유자의 범위가 끝나면(블록이 끝나면), 값도 제거된다.

```rust
fn main() {
	{
		// 단순 데이터 (Stack 메모리 사용)
		let x = 1;
		let y = x;
		println!("x = {x}, y= {y}")
	}
	  
	{
		// 문자열 String (Heap 메모리 사용)
		let s1 = String::from("hello");
		let s2 = s1;
		// println!("s1 = {s1}, s2 = {s2}"); // ❌에러가 발생한다. 더이상 s1을 사용할 수 없다
		// 기존에 String::from("Hello") 라는 데이터의 소유자가 S1이었다가 S2로 소유권을 넘기게 됨.
		// S1에 할당된 메모리는 S2로 넘기면서 메모리 해제가 일어남
	}
}
```
rust에서는 값 자체를 자동으로 복사해주는 기능을 지원하지 않는다.

자바스크립트를 예로 들면
s1 = "안녕";
s2 = s1;
이라는 코드가 실행되면
s2는 s1 변수의 포인터가 가리키는 데이터값을 복사해서 s2라는 변수로 저장하게 된다.
두개의 메모리 공간을 사용하는 셈
js의 깊은복사, 얕은 복사 개념을 가지고 온다면 저런 단순데이터의 복사는 모두 깊은 복사가 됨. (원본과의 참조가 없는 새로운 데이터 생성)

하지만, rust에서 heap 메모리를 사용하는 데이터의 경우
s1 = "안녕";
s2 = s1;
라는 코드가 실행되면 기존 s1의 데이터를 얕은 복사를 해옴과 동시에 (원본 데이터를 그대로 참조)
기존의 s1 변수와의 연결을 끊어버린다 (소유권 박탈)

그래서 더이상 s1 변수를 사용할 수 없게 된다.


### clone()
s1 변수를 그대로 사용하고 싶다면
s2 = s1; 
대신에
s2 = s1.clone();
이라는 함수를 사용하면 된다. 그러면 heap메모리 자체를 복사하면서 메모리 내에는 "안녕" 이라는 값이 2개가 저장되게 된다!


## 기본 데이터 타입의 복사
Stack에만 자리하는 값
- 모든 정수 타입 (u32, i64 ....)
- bool
- char
- tuple - 내부의 값이 위 타입인 경우
- ❌ tuple 내부의 값 중 Heap에 저장되는 값(String)이 있는 경우에는 해당되지 않음
- => 복사 시에도 소유권 이전이 일어나지 않음


## 함수 호출시 소유권 이동
```rust
fn main() {
	let s = String::from("헬로"); // heap 메모리 데이터
	string_length(s);
	println!("s = {}", s); // ❌ 이미 s의 소유권이 string_length 함수로 이동했기 때문에 불가능

	// 기본 데이터 타입 (Stack 이용)
	let x = 3;
	double(x);
	println!("x = {}", x); // ⭕️ 소유권의 이전 없이 복사가 일어나게 되어 x의 데이터는 유지
}

fn string_length(s: String) {
	println!("문자열의 길이는: {}", s.len());
}

fn double(x: i32) {
	println!("x의 2배는 : {}", 2*x)
}
```


# 함수 반환값의 소유권 이동
```rust
fn main() {
	let s1 = String::from("헬로");
	let s2 = string_length(s1); // Heap의 메모리는 같지만 구분해서 생각하기 위해 다른 변수명으로
	println!("s = {s}")
}

fn string_length(s: String) -> String {
	println!("문자열의 길이는: {}", s.len());
	s // 사용 후 반환
}
```

## 불필요한 소유권 이동 문제
```rust
fn main() {
	let s = String::from("헬로");
	let (len, s) = string_length(s); // s의 소유권을 넘긴 뒤 또다시 받아야 함 -> 번거로움
	println!("문자열 s = {} 의 길이는 = {}", s, len);
}

fn string_length(s: String) -> (usize, String) {
	println!("문자열의 길이는: {}", s.len());
	(s.len(), s) // 리턴값 여러개를 튜플로 반환할 수 있다
}
```
위와 같이 함수에 사용하고 다시 소유권을 넘겨받기 위해 불필요하게 코드가 복잡해지는 것을 볼 수 있다.
이를 어떻게 해결하면 좋을까? 

